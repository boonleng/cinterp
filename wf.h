/*
 * Name of source file:
 * wf.h
 *
 * Author:
 * Boon Leng Cheong
 *
 * Purpose:
 * This is a C framework for radar data reconstruction. It was developed in an effort to
 * filter wind turbine clutter in radar data. While the framework was originally developed
 * to touch up data cells with wind-turbine interference, it may be used to touch up for
 * other types of contaminations where the region is small and linear prediction method is
 * suitable for data regeneration. Since it was developed in C, this framework can be
 * integrated into any programs developed in C or any superset of C language, e.g., C++ or
 * Objective C.
 *
 * Results:
 * This software framework was created to facilitate radar data touch up where wind-turbine
 * contamination was determined by the user. For every cell that covers any wind turbines
 * specified in the location text file, the cell will be marked to for reconstruction. It is
 * permissable to have multiple wind turbines located within a radar cell but the software
 * framework has a process that consolidates all the radar cells into a unique set. During
 * the reconstruction process, the closest four surround cells in azimuth and range will
 * first be located. Since weather phenomena are usually contiguous, it is assumed that a
 * gradual change is present throughout the containminated area and, thus, the selected cell
 * will be regenerated by linearly interpolating the four cells, taking into account the
 * Euclidean distance of the cell in question and the surrounding four cells. In cases where
 * not all four cells are valid, i.e., one or more of them are censored, only a subset of
 * the four cells will be used.
 *
 * Reference Documentation:
 * Wind Turbine Filter Framework Document
 *
 * Revision History:
 * 2014/06/17 - Version 1.0.1
 *            - Increased WF_MAX_CELL_COUNT from 1024 to 65536
 *            - Improved failure handling
 * 2014/05/10 - Version 1.0 created.
 *
 */

#ifndef _H_WF_
#define _H_WF_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <math.h>
#include "misc.h"

#define WF_DEFAULT_CONFIG_FILE  "wtloc.txt"           /* Default wind turbine location           */
#define WF_DEFAULT_PAD_RANGE    250.0                 /* Default padding in range                */
#define WF_DEFAULT_PAD_AZ       1.0                   /* Default padding in azimuth              */
#define WF_STRLEN               1024                  /* Default character buffer length         */
#define WF_EARTH_RADIUS         6371000.0             /* Earth radius in meters                  */
#define WF_MAX_CELL_COUNT       65536                 /* Maximum number of filtered cells        */
#define WF_MAX_SWEEP_COUNT      8                     /* Maximum number of sweeps for filtering  */

/* WFExpandFlag - specifies the cluster expansion options */
typedef enum {
    WF_EXPAND_FLAG_NONE              = 0,             /* None                                    */
    WF_EXPAND_FLAG_RANGE_NEGATIVE    = 1,             /* Expand in range in negative direction   */
    WF_EXPAND_FLAG_RANGE_POSITIVE    = 1 << 1,        /* Expand in range in negative direction   */
    WF_EXPAND_FLAG_RANGE_BOTH        = 0x03,          /* Expand in range in both directions      */
    WF_EXPAND_FLAG_AZIMUTH_NEGATIVE  = 1 << 2,        /* Expand in azimuth in negative direction */
    WF_EXPAND_FLAG_AZIMUTH_POSITIVE  = 1 << 3,        /* Expand in azimuth in positive direction */
    WF_EXPAND_FLAG_AZIMUTH_BOTH      = 0x0C,          /* Expand in azimuth in both directions    */
    WF_EXPAND_FLAG_ALL               = 0x0F           /* Expand in both range and azimuth        */
} WFExpandFlag;

/* WFCellState - specifies the state of a cell */
typedef enum {
    WF_STATE_NORMAL             = 0,                  /* Normal weather               */
    WF_STATE_REGENERATE         = 1,                  /* Regenerate value in the cell */
    WF_STATE_CENSOR             = 1 << 1              /* Cell should be censored      */
} WFCellState;

/* WFInterpFlag - specifies the interpolation options */
typedef enum {
    WF_INTERP_FLAG_NULL                   = 0,        /* No option                                       */
    WF_INTERP_FLAG_GENERATE_CELL_STATE    = 1,        /* Generate cell state                             */
    WF_INTERP_FLAG_USE_CELL_STATE         = 1 << 1,   /* Use the supplied cell state                     */
    WF_INTERP_FLAG_MAP_DB_TO_LINEAR       = 1 << 2,   /* Map data from dB to linear scale (S, dBZ & ZDR) */
    WF_INTERP_FLAG_MAP_TO_COMPLEX         = 1 << 3    /* Map data to complex plane (V, PhiDP, etc)       */
} WFInterpFlag;

/* WFMoment - specifies the radar moment product */
typedef enum {
    WF_MOMENT_S = 1,                                  /* Signal power                    */
    WF_MOMENT_Z = 2,                                  /* Reflectivity                    */
    WF_MOMENT_V = 3,                                  /* Velocity                        */
    WF_MOMENT_W = 4                                   /* Width                           */
} WFMoment;

/* WFCoordStruct - a point coordinate on the Earth surface */
typedef struct WFCoord {
    double  latitude;                                 /* Latitude component of a coordinate  */
    double  longitude;                                /* Longitude component of a coordinate */
} WFCoordStruct;

/* WFConfigStruct - A collection of user configuration parameters */
typedef struct WFConfig {
    char           verb;                              /* Verbosity level of the framework     */
    float          paddingInAzimuthDegrees;           /* Padding in azimuth in degrees        */
    float          paddingInRangeMeters;              /* Padding in range in meters           */
    float          globalMultipathLength;             /* Global multipath extension in meters */
    WFCoordStruct  *turbineLocation;                  /* An array of wind turbine locations   */
    float          *multipathLength;                  /* An array of multipath extension      */
    size_t         count;                             /* Wind turbine count                   */
} WFConfigStruct;

/* WFRayStruct - A collection of radar data including the scan direction, moment type and the values
 * of the moment data. Multiple rays may be grouped together to form a sweep.
 */
typedef struct WFRay {
    float   azimuthBegin;                             /* Beginning azimuth of the ray   */
    float   azimuthEnd;                               /* Ending azimuth of the ray      */
    float   elevationBegin;                           /* Beginning elevation of the ray */
    float   elevationEnd;                             /* Ending elevation of the ray    */
    float   *data;                                    /* A pointer to the data values   */
} WFRayStruct;

/*  WFSweepStruct - A unit encapsulates multiple rays of radar data
 *
 *  A sweep is a collection of rays of moment. In the WF framework, a sweep contains only one type
 *  of moment data. Different moment type should be grouped together with another sweep collection.
 *  It is the user's responsibility to allocate sufficient amount of memory in the \a rays member
 *  to accomdate all the rays within a sweep.
 *
 *  A sweep can be either from a PPI (Plane Position Indicator) scan or an RHI (Range Height Indicator)
 *  scan. Only the sweep elevation (for PPI) or the sweep azimuth (for RHI) is specified but not
 *  both are needed. They are simply placeholder for housekeeping. The sweep angle is not used
 *  in the processing stage.
 *
 *  Range parameters (rangeCount, rangeDelta and rangeStart) must be properly set in
 *  meters so that correct locations of the radar cells can be derived from a set of latitude-
 *  longitude pairs.
 */
typedef struct WFSweep {
    float        elevation;                            /* Sweep elevation (PPI)                  */
    float        azimuth;                              /* Sweep azimuth (RHI)                    */
    float        azimuthDelta;                         /* Azimuth spacing in degrees             */
    float        nyquistVelocity;                      /* Nyquist velocity                       */
    WFMoment     moment;                               /* Moment type                            */
    size_t       rangeCount;                           /* Number of range samples                */
    float        rangeDelta;                           /* Range gate spacing in meters           */
    float        rangeStart;                           /* Range of the first sample              */
    size_t       rayCount;                             /* Number of rays in the sweep            */
    WFRayStruct  *rays;                                /* A pointer to the collection of wf_rays */
} WFSweepStruct;

/* Target coordinate with respect to the radar origin */
typedef struct WFRadarCoord {
    float elevation;                                   /* The elevation in degrees */
    float azimuth;                                     /* The azimuth in degrees   */
    float range;                                       /* The range in meters      */
} WFRadarCoordStruct;

/* Radar cell index */
typedef struct WFRadarCellId {
    size_t clusterId;                                  /* The reference index of the cluster */
    size_t azimuthId;                                  /* Index of azimuth                   */
    size_t rangeId;                                    /* Index of range                     */
    size_t rangeExtensionCount;                        /* Range extension due to multipath   */
} WFRadarCellId;

/* Wind turbine counts */
typedef union WFCount {
    struct {
        size_t turbines;                               /* Turbines alone                              */
        size_t turbinesAndMultipath;                   /* Turbines and multipath extension            */
        size_t turbinesMultipathAndPadding;            /* Turbines, multipath extension and padding   */
        size_t turbinesMultipathPaddingAndBoundary;    /* All of the above plus the surrounding cells */
        size_t clusterId;                              /* Number of clusters                          */
    };
    struct {
        size_t rawInput;                               /* Turbines alone                              */
        size_t rawInputExtended;                       /* Turbines and multipath extension            */
        size_t badCells;                               /* Turbines, multipath extension and padding   */
        size_t badAndGoodCells;                        /* All of the above plus the surrounding cells */
        size_t clusters;                               /* Number of clusters                          */
    };
    size_t v[8];
} WFCountStruct;

#pragma mark -
#pragma mark Coordinate

/* WFCoordStructMake
 *
 * creates a coordinate from give latidue and longitude
 *
 * Returns:
 *   A coordinate
 */
WFCoordStruct WFCoordStructMake(double latitude,       /* Latitude  */
                                double longitude);     /* Longitude */

#pragma mark -
#pragma mark Configuration

/* WFConfigInit
 *
 * initializes a configuration structure quietly using default location file (wtloc.txt)
 *
 * Returns:
 *   A configuration structure
 */
WFConfigStruct *WFConfigInit(void);

/* WFConfigInitFromFile
 *
 * initializes a configuration structure using a supplied input file. Verbosity level
 * specificies the amount of messages generated to stdout by the function
 *
 * Input Parameters:
 *   file - A filename to get the input parameters
 *   verb - Verbose level
 *
 * Returns:
 *   A configuration structure
 */
WFConfigStruct *WFConfigInitFromFile(const char *file,  /* Input filename */
                                     const char verb);  /* Verbose level  */

/* WFConfigRelease
 *
 * releases resources occupy but the configuration structure
 *
 * Input Parameters:
 *   config - A configuration structure
 */
void WFConfigRelease(WFConfigStruct *config);  /* Configuration structure */

/* WFConfigShowSummary
 *
 * shows a summary of the configuration structure
 *
 * Input Parameters:
 *   config - A configuration structure
 */
void WFConfigShowSummary(WFConfigStruct *config);  /* Configuration structure */

#pragma mark -
#pragma mark Coordinate Transformations


/* WFGetRadarCoord
 *
 * gets a single radar centric coordinate from a lat/lon coordinate. For multiple
 * coordinate in an array, use WFDeriveRadarCoords(), which is more efficient for
 * an array of coordinates.
 *
 * Input Parameters:
 *   targetCoord - A target coordinate in lat/lon
 *   radarCoord  - The radar coordinate in lat/lon
 *
 * Returns:
 *   a WFRadarCoordStruct of the target coordinate
 */
WFRadarCoordStruct WFGetRadarCoord(const WFCoordStruct targetCoord,   /* Target coordinate */
                                   const WFCoordStruct radarCoord);   /* Radar coordinate  */

/* WFDeriveRadarCoords
 *
 * gets an array of radar centric coordinates from an array of lat/lon coordinates.
 * User must make sure the output array coords has been been allocated to house
 * <count> elements.
 *
 * Input Parameters:
 *   targets  - Set of target coordinates in lat/lon
 *   origin   - The radar coordinate in lat/lon
 *   count    - The number of elements of the input/output arrays
 *
 * Output Parameters:
 *   coords   - An array for the derived radar coordinates
 */
void WFDeriveRadarCoords(WFRadarCoordStruct *coords,     /* Target's radar coordinates   */
                         const WFCoordStruct *targets,   /* Target's lat/lon coordinates */
                         const WFCoordStruct *origin,    /* Radar's lat/lon coordinate  */
                         size_t count);                  /* Number of elements           */

/* WFDeriveRadarCellIds
 *
 * gets an array of radar cell indices from an array of radar centric coordinates
 *
 * Input Parameters:
 *   sweep    - The radar sweep to derive the indices
 *   coords   - A set of radar coordinates
 *   count    - The number of elements of the input and output arrays
 *
 * Output Parameters:
 *   cell_ids - An array of cell indices corresponding the input array
 *
 * Returns:
 *   The count of elements that is within the radar range
 */
size_t WFDeriveRadarCellIds(WFRadarCellId *cellIds,              /* An array of cell indices            */
                            const WFSweepStruct *sweep,          /* The radar sweep to map the indices  */
                            const WFRadarCoordStruct *coords,    /* A set of radar cell coordinates     */
                            const WFConfigStruct *config);       /* Number of elements                  */

/* WFUniqueRadarCellIds
 *
 * reduces an array of radar cell indices to an array of unique radar cell indices
 *
 * Input Parameters:
 *   cellIds - An array of cell indices corresponding the output array. The
 *             array will be overridden with unique elements (output)
 *     count - The number of elements in the input arrays
 *
 * Output Parameters
 *   cellIds - An array of cell indices with only unique elements.
 *
 * Returns:
 *   The count of unique elements
 */
size_t WFUniqueRadarCellIds(WFRadarCellId *cell_ids,  /* Input/output array of cell indices    */
                            const size_t count);      /* Number of elements of the input array */

/* WFMultipathExtendRadarCellIds
 *
 * extends an array of radar cell indices by padding in range according to the
 * multipath bin counts of each cell index. The user must pre-allocate sufficient memory
 * in the input array as the same array will be used to insert new elements.
 *
 * Input Parameters:
 *   cellIds       - An array of cell indices corresponding the output array. The
 *                   array will be expanded with additional elements (output)
 *   sweep         - The radar sweep to use for cell index derivation
 *   multipathBins - The expansion dimension flag
 *   count         - The number of elements in the input arrays
 *   maxCount      - The maximum number of elements in the output arrays
 *
 * Output Parameters:
 *   cellIds       - An array of cell indices with expanded elements
 *
 * Returns:
 *   The count of the expanded elements
 */
size_t WFMultipathExtendRadarCellIds(WFRadarCellId *cellIds,        /* Input/output array of cell indices */
                                     const WFSweepStruct *sweep,    /* Sweep for index derivation         */
                                     const size_t count,            /* Number of cell indices             */
                                     const size_t maxCount);        /* Maximum number of cell indices     */

/* WFExpandRadarCellIds
 *
 * expands an array of radar cell indices by padding a cross pattern to each element. The user
 * must pre-allocate sufficient memory in the input array as the same array will be used to
 * insert new elements.
 *
 * Input Parameters:
 *   cellIds  - An array of cell indices corresponding the output array. The
 *              array will be expanded with additional elements (output)
 *   sweep    - The radar sweep to use for cell index derivation
 *   flag     - The expansion dimension flag
 *   count    - The number of elements in the input arrays
 *   maxCount - The maximum number of elements in the output arrays
 *
 * Output Parameters:
 *   cellIds  - An array of cell indices with expanded elements
 *
 * Returns:
 *   The count of the expanded elements
 */
size_t WFExpandRadarCellIds(WFRadarCellId *cellIds,        /* Input/output array of cell indices    */
                            const WFSweepStruct *sweep,    /* Sweep for index derivation            */
                            const WFExpandFlag flag,       /* Expansion flag                        */
                            const size_t count,            /* Number of cell indices                */
                            const size_t maxCount);        /* Maximum number of cell indices        */

/* WFClusterRadarCellIds
 *
 * clusters radar cell indices that are continuous into a single body by assigning the cluster index
 *
 * Input Parameters:
 *   cellIds   - An array of cell indices, which will be filled with proper cell index (clusterId)
 *   sweep     - The radar sweep to use for cell index derivation
 *   count     - The number of elements in the input arrays
 *
 * Output Parameters:
 *   cellIds   - The input array filled with proper cell index
 *
 * Returns:
 *   The number of clusters
 */
size_t WFClusterRadarCellIds(WFRadarCellId *cellIds,        /* Input/output array of cell indices    */
                             const WFSweepStruct *sweep,    /* Sweep for index derivation            */
                             const size_t count);           /* Number of cell indices                */

#pragma mark -
#pragma mark Data Censoring and Reconstruction

/* Functions that censor and regenerate radar data
 *
 * These functions are the high-level interaction with the framework. Once a set of wind turbine locations
 * in latitude-longitude pair is known, these high-level functions can be called to get a set of radar-centric
 * indices indicating where the data should be censored. A general workflow would be to start with an array
 * of coordinate where interference is expected, then convert this array of coordinate into a radar referenced
 * frame, i.e., coordinate in WFRadarCoord (elevation, azimuth, range) so that proper radar cells can be
 * located. Then, functions such as WFInterpData() or WFSmartInterpData() is used to regenerate the
 * data where the cells were marked contaminated.
 */


/* WFCreateCensorRadarCellIds
 *
 * creates an array of cell indices that should be used for censoring. It should be noted that a
 * new memory space will be created at *ptrCellIds and this resource must be deallocated by
 * the function WFFreeCensorRadarCellIds().
 *
 * Input Parameters:
 * ptrCellIds        - The pointer to allocate and store the <cellIds>. A new memory space will be allocated.
 * sweep             - The radar sweep to use for cell index derivation
 * origin            - The radar coordinate
 * config            - A configuration parameter describing the wind turbine setup
 *
 * Output Parameters:
 * cellCounts        - The number of cells to be filtered
 *                     First number indicates the unique count from the configuration parameters
 *                     Second number indicates the expanded count including to multipath
 *                     Third number indicates the expanded count including padding
 *                     Forth number indicates the number of surround good cells
 */
void WFCreateCensorRadarCellIds(WFCountStruct *cellCounts,        /* The number of cells                         */
                                WFRadarCellId **ptrCellIds,       /* The pointer to allocate & store the cellIds */
                                const WFSweepStruct *sweep,       /* The radar sweep for cell index derivation   */
                                const WFCoordStruct *origin,      /* Origin of the radar                         */
                                const WFConfigStruct *config);    /* A configuration parameter enclosing unit    */

/* WFReleaseCensorRadarCellIds
 *
 * releases the resources for cell indices
 *
 * Input Parameters:
 * cellIds - An array of cell indices to be released, which were created by functions with prefix WFCreate
 */
void WFReleaseCensorRadarCellIds(WFRadarCellId *cellIds);   /* An array of cell indices to be released */


/* WFBilinearInterpData
 *
 * interpolates the data at cellIds by using the surrounding cells that contain good
 * data. Whenever specified, an array of WFCellState will be generated, through malloc(),
 * which can be reused for subsequenct WFInterpData() calls to maintain the same censoring
 * mask where no data is expected at certain cellIds. This will guarantee all the data from
 * the same time level share the same censoring mask.
 *
 * Input Parameters:
 *   sweep          - The radar sweep. Cells at incides in cellIds array will be replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls
 *   cellIds        - An array of cell indices indicating positions to replace
 *   flag           - Options for this function. This can be constructed by applying logically OR to a
 *                    set of WFExpandFlag parameters. It is required that flag must at least have
 *                    WF_INTERP_FLAG_GENERATE_CELL_STATE or WF_INTERP_FLAG_USE_CELL_STATE
 *   count          - The number of elements in cellIds
 *
 * Output Parameters:
 *   sweep          - Same array but with cells at indices in cellIds array replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls. This mask is allocated if
 *                    the flag is WF_INTERP_FLAG_GENERATE_CELL_STATE
 */
void WFBilinearInterpData(WFSweepStruct *sweep,            /* The radar sweep corresponds to the data  */
                          WFCellState **ptrCellStates,     /* An array of housekeeping states          */
                          const WFRadarCellId *cellIds,    /* Cell indices                             */
                          const WFInterpFlag flag,         /* Processing parameters                    */
                          const WFCountStruct *counts);    /* Various counts in cellIds                */


/* WFSelectiveBilinearInterpData
 *
 * interpolates the data at cells cellIds by selectively only using surrouding cells that contain good
 * data. This function is similar to WFInterpData() but this method uses a decision tree to adaptively
 * select the best interpolation method based on the availability of surround cells. For cells that
 * only have less than four good surround cells, only a subset of them are used to reconstruct the cell
 * of interest.
 *
 * Input Parameters:
 *   data           - An array of data. Cells in cellIds will be replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls
 *   sweep          - The radar sweep corresponds to the data
 *   cellIds        - An array of cell indices indicating positions to replace
 *   flag           - Options for this function. This can be constructed by applying logically OR to a
 *                    set of WFExpandFlag parameters. It is required that flag must at least have
 *                    WF_INTERP_FLAG_GENERATE_CELL_STATE or WF_INTERP_FLAG_USE_CELL_STATE
 *   count          - The number of elements in cellIds
 *
 * Output Parameters:
 *   data           - Same array but with cells at indices in cellIds array replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls. This mask is allocated if
 *                    the flag is WF_INTERP_FLAG_GENERATE_CELL_STATE
 */
void WFSelectiveBilinearInterpData(WFSweepStruct *sweep,            /* The radar sweep corresponds to the data  */
                                   WFCellState **ptrCellStates,     /* An array of housekeeping states          */
                                   const WFRadarCellId *cellIds,    /* Cell indices                             */
                                   const WFInterpFlag flag,         /* Processing parameters                    */
                                   const WFCountStruct *counts);    /* Various counts in cellIds                */


/* WFInverseDistanceInterpData
 *
 * interpolates the data at cells cellIds by using the surrounding cells that contain good data using a
 * so called inverse-distance interpolation. Good surrounding cells with finite numbers all all used in
 * this method by weight and sum where the individual weight of each good cell is inversely proportional
 * to the distance in between the target cell and the good cell.
 *
 * Input Parameters:
 *   data           - An array of data. Cells in cellIds will be replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls
 *   sweep          - The radar sweep corresponds to the data
 *   cellIds        - An array of cell indices indicating positions to replace
 *   flag           - Options for this function. This can be constructed by applying logically OR to a
 *                    set of WFExpandFlag parameters. It is required that flag must at least have
 *                    WF_INTERP_FLAG_GENERATE_CELL_STATE or WF_INTERP_FLAG_USE_CELL_STATE
 *   counts         - Various counts (refer WFCountStruct) in cellIds
 *
 * Output Parameters:
 *   data           - Same array but with cells at indices in cellIds array replaced
 *   ptrCellStates  - An array of housekeeping states for subsequent calls. This mask is allocated if
 *                    the flag is WF_INTERP_FLAG_GENERATE_CELL_STATE
 */
void WFInverseDistanceInterpData(WFSweepStruct *sweep,            /* The radar sweep corresponds to the data  */
                                 WFCellState **ptrCellStates,     /* An array of housekeeping states          */
                                 const WFRadarCellId *cellIds,    /* Cell indices                             */
                                 const WFInterpFlag flag,         /* Processing parameters                    */
                                 const WFCountStruct *counts);    /* Various counts in cellIds                */

#endif

